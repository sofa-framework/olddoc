\documentclass[a4paper,11pt]{article}
% LaTeX2Html: setenv TEXINPUTS `pwd`/fig:; latex2html

% ---- graphiques
\usepackage{graphicx}
%\graphicspath{./fig} 
%\usepackage{subfigure}  % several figures in a figure
%\usepackage{pstricks}

% ---- couleurs
% \usepackage[dvips]{color}
% \pagecolor[gray]{1}         % couleur de fond (blanc)

% ---- inclusion de codes

\usepackage{listings}
\lstset{showstringspaces=false,frame=trBL,frameround=tttt,tabsize=4,basicstyle=\tiny,breaklines=true,breakatwhitespace=true}
\lstdefinestyle{bash}{language=bash}
\lstdefinestyle{Perl}{language=Perl}
\lstdefinestyle{C++}{language=C++}
\lstdefinestyle{DTD}{language=XML}
\lstdefinestyle{XML}{language=XML,usekeywordsintag=false,markfirstintag=true}
\newcommand{\includecode}[2]{\lstinputlisting[style=#1]{#2}}
%\lstnewenvironment{code}{}{}
\lstnewenvironment{code_bash}{\lstset{style=bash}}{}
\lstnewenvironment{code_perl}{\lstset{style=Perl}}{}
\lstnewenvironment{code_cpp}{\lstset{style=C++}}{}
\lstnewenvironment{code_dtd}{\lstset{style=DTD}}{}
\lstnewenvironment{code_xml}{\lstset{style=XML}}{}

\newcommand{\textcode}[1]{{\small {\tt #1}}}

% ---- liens entre le dvi généré et les fichiers sources latex
%\usepackage[active]{srcltx}

% ---- format de page A4
	\setlength{\textwidth }{16cm}	% largeur de ligne
	\setlength{\textheight}{23cm}   % hauteur du texte
	\setlength{\oddsidemargin}{0cm} % marge pages impaires
	\setlength{\evensidemargin}{0cm}% marge pages paires
	\setlength{\topmargin}{0cm} 	
	\setlength{\headheight}{14pt} 
	\setlength{\headsep}{0.5cm} 

%\renewcommand{\floatpagefraction}{1}

% Title Page
\title{Introduction to \sofa}
\author{The \sofa~team}
\date{2007}
% \author{Fran\c{c}ois Faure\\ J\'er\'emie Allard\\ {\small INRIA Rh\^one-Alpes, Grenoble, France}}

% ------ my custom commands
\newcommand{\sofa}{SOFA }
\newcommand{\todo}[1]{}
\newcommand{\eg}{\textit{e.g.} }
\include{macros_docu}

\begin{document} 
\maketitle

% \begin{abstract}
% This is the documentation of the SOFA library. Chapter~\ref{chapter:pba} gives theoretical background on physically-based animation. Chapter~\ref{chapter:as} shows how to implement simulations using \sofa. Chapter~\ref{chapter:es} describes how to integrate new components in \sofa.
% \end{abstract}

\tableofcontents


\section{Brief overview}
\sofa is an open-source C++ library for physical simulation, primarily targeted to medical simulation.
It can be used as an external library in another program, or using one of the associated GUI applications.

The main feature of \sofa  compared with other libraries is its high flexibility. It allows the use of multiple interacting geometrical models of the same object, typically, a mechanical model with mass and constitutive laws, a collision model with simple geometry, and a visual model with detailed geometry and rendering parameters. Each model can be designed independently of the others. During run-time, consistency is maintained using mappings.


Additionally, \sofa  scenes are modeled using a data structure similar to hierarchical scene graphs commonly used in graphics libraries. This allows the splitting of the physical objects into collections of independent components, each of them describing one feature of the model, such as mass, force functions and constraints.
For example, you can replace spring forces with finite element forces by simply replacing one component with another, all the rest (mass, collision geometry, time integration, etc.) remaining unchanged.

Moreover, simulation algorithms, such as time integration or collision detection and modeling, are also modeled as components in the scene graph. This provides us with the same flexibility for algorithms as for models.

Flexibility allows one to focus on its own domain of competence, while re-using the other's contributions on other topics. 
However, efficiency is a major issue, and we have tried to design a framework which allows both efficiency and flexibility.



\section{Commented example} \label{sec:commentedExample}
Figure~\ref{fig:mixedPendulum} shows a simple scene composed of two different objets, one rigid body and one particle system, and linked by a spring.
\begin{figure}
 \centering
 \includegraphics[width=0.9\linewidth]{mixedPendulum.png}
 \caption{A pendulum composed of a rigid body (reference frame and yellow point) attached to an elastic string (green) fixed at one end (pink point). The corresponding scene graph is displayed on the left.}
 \label{fig:mixedPendulum}
\end{figure}
This scene is modeled and simulated in C++ as shown in appendix~\ref{cpp:hybrid}. The corresponding scene graph is shown in figure~\ref{fig:mixedPendulum-graph}. Note that the graph in the left of figure~\ref{fig:mixedPendulum} only displays a hierarchical view, while the whole graph includes additional pointers displayed as dashed arrows in figure~\ref{fig:mixedPendulum-graph}.
\begin{figure}
 \centering
 \includegraphics[width=\linewidth]{mixedPendulum-graph}
 \caption{The scene graph of the mixed pendulum. The nodes are displayed as grey hexagons, while the components are displayed as rectangles with colors associated with their types or roles. The bold plain arrows denote node hierarchy, while the thin plain arrows point to the components attached to the nodes, and the dotted arrows denote pointers between components.}
 \label{fig:mixedPendulum-graph}
\end{figure}

The scene is modeled as a tree structure with four nodes:
\begin{itemize}
 \item \texttt{root} 
 \item \texttt{deformableBody} corresponds to the elastic string
 \item \texttt{rigidBody} corrsponds to the rigid object
 \item \texttt{rigidParticles} corresponds to a set of particles (only one in this case) attached to the rigid body
\end{itemize}
Each node can have children nodes and \textit{components}. Each component implements a reduced set of functionalities.


One of the most important type of component is the \texttt{MechanicalObject}, which contains a list of \textit{degrees of freedom} (DOF), i.e. coordinates, velocities, and associated auxiliary vectors such as forces and accelerations. 
All the coordinates in a \texttt{MechanicalObject} have the same type, e.g. 3D vectors particles, or (translation, rotation) pairs for rigid bodies. \texttt{MechanicalObject}, like many other \sofa classes, is a generic (C++ template) class instantiated on the types of DOF it stores.
The particle DOFs are drawn as white points, whereas the rigid body DOFs are drawn as red, green, blue reference frame axes.
There can be at most one \texttt{MechanicalObject} attached to a given node. This guarantees that all the components attached to the same node process the same types of DOF. Consequently, the particles and the rigid body necessarily belong to different nodes. 

In this example, the masses are stored in \texttt{UniformMass} components.
The types of their values are related to the types of their associated DOF.
\texttt{UniformMass} is derived from the abstract \texttt{Mass} class, and stores only one value, for the case where all the associated objects have the same mass. If necessary, it can replaced by a \texttt{DiagonalMass} instanciated on the same DOF types, for the case where the associated objects have different masses. This is an important feature of \sofa: each component can be replaced by another one deriving from the same abstract class and instanciated on the same DOF types. This results in a high flexibility.

The \texttt{FixedConstraint} component attaches a particle to a fixed point in world space, drawn in pink. The constraints act as filters which cancel the forces and displacements applied to their associated particle(s). They do not model more complex constraints such as maintaining three points aligned.

The \texttt{StiffSpringForceField} stores a list of springs, each of them modeled by a pair of indices, as well as the standard physical parameters, stiffness, damping and rest length.

The rigid body is connected to the deformable string by a spring.
Since this spring is shared by the two bodies, it is modeled in the \texttt{StiffSpringForceField} attached to a common ancestor, the graph root in this example.
Our springs can only connect particles. We thus need to attach a particle to the rigid body. Since the particle DOFs types are different from the rigid body DOF types, they have to be stored in another \texttt{MechanicalObject}, called \texttt{rigidParticleDOF} in this example, and attached to a different node. 
However, \texttt{rigidParticleDOF} is not a set of independent DOF, since they are fixed in the reference frame of the rigid body. We thus attach it to a child node of the rigid body, and connect it to \texttt{rigidDOF} using a \texttt{RigidMapping}. This component stores the coordinates of the particle in the reference frame of the rigid body. Its task is to propagate the position, velocity and displacement of the rigid body down to the yellow particle, and conversely, to propagate the forces applied to the particle up to the rigid body.

Mappings are one of the major features of \sofa. They allow us to use different geometric models for a given body, e.g. a coarse tetrahedral mesh for viscoelastic internal forces, a set of spheres for collision detection and modeling, and a fine triangular mesh for rendering.

The gravity applied to the scene is modeled in the \texttt{Gravity} component near the root. It applies to all the scene, unless locally overloaded by another gravity component inside a branch of the tree.

So far, we have discussed the physical model of the scene. 
To animate it, we need to solve an \textit{Ordinary Differential Equation} (ODE) in time. 
There are plenty of ODE solvers, and \sofa allows the design and the re-use of a wide variety of them. 
Here we use a simple explicit Euler method, modeled using an \texttt{EulerSolver} component.
It triggers computations such as force acumulation, acceleration computation and linear operations on state vectors.
More sophisticated solvers are available in \sofa, and can be used by simply replacing the  \texttt{EulerSolver} component by another one, e.g \texttt{RungeKutta4} or \texttt{CGImplicit}.

Other capabilities of \sofa, such as collision detection and response, will be discussed in subsequent sections.

\section{Multi-model objects} \label{sec:multimodel}
An important feature of Sofa is the possibility of using different models of a single physical object. Figure~\ref{fig:liver} shows a scene graph representing a liver, and three different images of it.
The liver exhibits three different geometries for mechanics, rendering and collision.
\begin{figure}
 \centering
 \includegraphics[width=0.95\linewidth]{liver_graph}\\
 \includegraphics[width=0.3\linewidth]{liver_smooth_visu}
 \includegraphics[width=0.3\linewidth]{liver_behavior}
 \includegraphics[width=0.3\linewidth]{liver_collision}
 \caption{A liver. Top: scene graph. Bottom: visual model, mechanical model, collision model, respectively.}
 \label{fig:liver}
\end{figure}
The corresponding xml code is given in appendix~\ref{xml:liver}.
\label{bla:liver}

On top of the scene, collision-related components allow a user to interact with the collision models using rays casted from the mouse pointer and hitting collision models. Collision is discussed in section~\ref{sec:collision}.

The liver is modeled using three nodes, in two levels. The parent level contains the mechanical dofs (particle positions and velocities) in a \texttt{MechanicalObject} component. These dofs are the mechanically independent degrees of freedom of the object, in Lagrange's formalism. The node also contains components related to the dynamics of the particles, such as mass and internal forces. We call it the \textit{behavior model}.

The two other nodes are in the lower level because during the simulation, their coordinates are totally defined by the coordinates of their parent node. Thus, they do not belong to the set of mechanically independent dofs. \emph{Mappings} are used to compute their positions and velocities based on their parent's, using the pointers represented as dashed arrows. Mappings are not symmetric. The motion of the parent dofs is mapped to the children dofs, whereas the motion of the children dofs is not mapped to their parent. This ensures consistency. 

The \texttt{VisualModel} has vertices which are used for rendering, along with other rendering data such as a list of polygons, normals, etc. The mapping is one-way and the mapped dofs have no mechanical influence.

The \texttt{SphereModel} class derives from \texttt{MechanicalObject}, with an additional radius value. It also derives from \texttt{CollisionModel}, which allows it to be processed by the collision detection and modeling pipeline. When contact or mouse interaction forces are applied to the spheres, the forces are propagated bottom-up to their parent dofs by the mapping. This allows the contact forces to be taken into account in the dynamics equations. The mapping is thus two-ways and derives from \texttt{MechanicalMapping} instead of \texttt{Mapping}. This is why it has a different color in the image of the scene graph.
Again, the mechanical mappings are not symmetric: the forces are propagated from the children to the parents, not the other way round. 

Mappings only propagate positions top-down, whereas MechanicalMappings additionally propagate velocities top-down and forces bottom-up. 

Mapped models can be designed independently of their parent models, provided that the adequate (mechanical) mapping is available. This results in a high flexibility. For example, collision spheres can be replaced by collision triangles without changing anything in the behavior model or in the visual model. Similarly, other visual models can be used without modifying the behavior and collision models, and different behavior models can be used with the same collision and visual models, as illustrated in figure~\ref{fig:behaviormodels}.

\begin{figure}
 \centering
 \includegraphics[width=0.4\linewidth]{demoLiverFall1.png}
 \includegraphics[width=0.4\linewidth]{demoLiverFall2.png}
 % demo.: 1179666x1179666 pixel, 0dpi, infxinf cm, bb=
 \caption{Left: four behavior models (from left to right: deformable grid, springs, rigid, tetrahedral FEM) combined with the same collision model (right).}
 \label{fig:behaviormodels}
\end{figure}


\section{Actions}

\section{Mappings}

\section{ODE Solvers}

\section{Collision detection} \label{sec:collision}

\section{Constraint-based methods}

\section{File format}

\section{Limitations}

\pagebreak
\appendix
\section{Code of the examples}
\subsection{The hybrid pendulum}\label{cpp:hybrid}
This is the code of the example commented in section~\ref{sec:commentedExample}.
\includecode{C++}{../applications/tutorials/mixedPendulum/Main.cpp}

\subsection{A liver}\label{xml:liver}
This is the XML code of the liver discussed in section~\ref{sec:multimodel} page~\pageref{bla:liver}.
\includecode{XML}{../scenes/liver.scn}

% \include{sofaMechanical}
% 
% \include{extendingSofa}
% 
% \include{physicallyBasedAnimation}
% 
% \include{appendices}








\end{document}          
